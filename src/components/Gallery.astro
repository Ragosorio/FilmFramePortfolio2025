---
import { Image } from "astro:assets";
import ArrowDown from "@/assets/videos/downrow2.gif";
---

<div class="container font-Seasons">
  <section class="steps">
    <div class="step-counter">
      <div class="counter-title">
        <h1>Gallery</h1>
      </div>
      <div class="count">
        <div class="count-container">
          <h1>Video 1</h1>
          <h1>Video 2</h1>
          <h1>Video 3</h1>
          <h1>Video 4</h1>
          <h1>Video 5</h1>
        </div>
      </div>
    </div>

    <div class="cards">
      <div class="card">
        <div class="card-img">
          <img src="https://picsum.photos/800/450?random=1" alt="Video 1" />
        </div>
        <div class="card-content">
          <p>
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Repellendus
            eveniet harum ipsum cupiditate quas laborum similique iure veritatis
            illo odit rerum.
          </p>
        </div>
      </div>

      <div class="card">
        <div class="card-img">
          <img src="https://picsum.photos/800/450?random=2" alt="Video 2" />
        </div>
        <div class="card-content">
          <p>
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Repellendus
            eveniet harum ipsum cupiditate quas laborum similique iure veritatis
            illo odit rerum.
          </p>
        </div>
      </div>

      <div class="card">
        <div class="card-img">
          <img src="https://picsum.photos/800/450?random=3" alt="Video 3" />
        </div>
        <div class="card-content">
          <p>
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Repellendus
            eveniet harum ipsum cupiditate quas laborum similique iure veritatis
            illo odit rerum.
          </p>
        </div>
      </div>

      <div class="card">
        <div class="card-img">
          <img src="https://picsum.photos/800/450?random=4" alt="Video 4" />
        </div>
        <div class="card-content">
          <p>
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Repellendus
            eveniet harum ipsum cupiditate quas laborum similique iure veritatis
            illo odit rerum.
          </p>
        </div>
      </div>

      <div class="card">
        <div class="card-img">
          <img src="https://picsum.photos/800/450?random=5" alt="Video 5" />
        </div>
        <div class="card-content">
          <p>
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Repellendus
            eveniet harum ipsum cupiditate quas laborum similique iure veritatis
            illo odit rerum.
          </p>
        </div>
      </div>
      <div class="card empty"></div>
      <div class="card empty"></div>
    </div>
    <div class="size-16 absolute bottom-5 md:bottom-0 left-1/2 -translate-x-1/2">
      <Image src={ArrowDown} alt="Arrow Down" class="" />
    </div>
  </section>
</div>

<style>
  img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  section.steps {
    position: relative;
    width: 100vw;
    height: 100dvh;
    overflow: hidden;
  }

  .cards {
    position: absolute;
    top: 25%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 150vw;
    height: 600px;
    will-change: transform;
  }

  .card {
    position: absolute;
    width: 600px;
    height: 450px;
    top: 60%;
    left: 50%;
    transform-origin: center center;
    margin-left: -300px;
    display: flex;
    flex-direction: column;
    gap: 1em;
    will-change: transform;
  }

  .card-img {
    flex: 1;
    border-radius: 0.5em;
    overflow: hidden;
    aspect-ratio: 16/9;
  }

  .card-content {
    width: 100%;
    height: 60px;
  }

  .card-content p {
    text-align: left;
    font-size: 16px;
    font-weight: 500;
    line-height: 1.25;
    color: #111;
  }

  .step-counter {
    position: absolute;
    display: flex;
    flex-direction: column;
    margin: 2em;
  }

  .counter-title,
  .count {
    position: relative;
    width: 1200px;
    height: 150px;
    clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
    overflow: hidden;
  }

  .count {
    top: -10px;
  }

  .count-container {
    position: relative;
    transform: translateY(150px);
    will-change: transform;
  }

  .step-counter h1 {
    width: 100%;
    position: relative;
    color: #111;
    text-transform: uppercase;
    font-weight: 900;
    font-size: 150px;
    line-height: 1;
    letter-spacing: -0.04em;
    will-change: transform;
  }

  .empty {
    opacity: 0;
  }

  @media (max-width: 900px) {
    .counter-title h1 {
      font-size: 60px;
    }

    .cards {
      top: 30%;
      left: 76%;
    }

    .card {
      width: 375px;
      height: 280px;
    }

    .card-img {
      aspect-ratio: 16/9;
    }

    .count {
      top: -100px;
      left: -10px;
      height: 100px;
    }

    .count-container h1 {
      height: 100px;
      line-height: 100px;
      font-size: 100px;
    }
  }

  @media (max-width: 450px) {
    .count-container h1 {
      font-size: 85px;
    }
  }
</style>

<script
  is:inline
  src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
<script
  is:inline
  src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollTrigger.min.js"
></script>
<script
  is:inline
  src="https://cdn.jsdelivr.net/npm/lenis@1.3.8/dist/lenis.min.js"></script>

<script is:inline>
  document.addEventListener("DOMContentLoaded", () => {
    gsap.registerPlugin(ScrollTrigger);

    // Detectar Chrome móvil específicamente
    const isChromeMotile = /Chrome/.test(navigator.userAgent) && /Mobile/.test(navigator.userAgent);
    
    // Configuración específica para Chrome móvil
    ScrollTrigger.config({
      ignoreMobileResize: true,
      // Para Chrome móvil, ser más conservador
      autoRefreshEvents: isChromeMotile ? "none" : "visibilitychange,DOMContentLoaded,load"
    });

    // Configuración de Lenis con velocidad adaptativa
    const lenis = new Lenis({
      duration: 1.0, // Fluido por defecto
      easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
      smooth: true,
      syncTouch: true,
      touchInertiaMultiplier: 25,
      wheelMultiplier: 0.8,
      touchMultiplier: 1.2
    });

    // Sistema de velocidad adaptativa para Chrome móvil
    let isNearStickySection = false;
    let currentScrollSpeed = 1.0;

    if (isChromeMotile) {
      // Crear zonas de scroll más lento
      const checkScrollZone = () => {
        const rect = stickySection.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        
        // Zona crítica: 200px antes y después de la sección sticky
        const isInCriticalZone = rect.top < viewportHeight + 200 && rect.bottom > -200;
        
        if (isInCriticalZone !== isNearStickySection) {
          isNearStickySection = isInCriticalZone;
          
          if (isInCriticalZone) {
            // SLOW MODE: Entrar a zona crítica
            currentScrollSpeed = 0.6;
            lenis.options.duration = 1.8;
            lenis.options.touchMultiplier = 0.8;
            console.log("🐌 Modo lento activado");
          } else {
            // FAST MODE: Salir de zona crítica
            currentScrollSpeed = 1.0;
            lenis.options.duration = 1.0;
            lenis.options.touchMultiplier = 1.2;
            console.log("🚀 Modo fluido activado");
          }
        }
      };

      // Verificar zona durante scroll
      lenis.on("scroll", checkScrollZone);
    }

    lenis.on("scroll", ScrollTrigger.update);
    gsap.ticker.add((time) => {
      lenis.raf(time * 1000);
    });

    gsap.ticker.lagSmoothing(0);

    // Forzar un viewport estable en Chrome móvil
    if (isChromeMotile) {
      const initialViewportHeight = window.innerHeight;
      const viewport = document.querySelector('meta[name=viewport]');
      if (viewport) {
        viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no');
      }
      
      // Establecer altura fija del documento
      document.documentElement.style.setProperty('--vh', `${initialViewportHeight * 0.01}px`);
    }

    const stickySection = document.querySelector(".steps");
    const cards = document.querySelectorAll(".card:not(.empty)");
    const countContainer = document.querySelector(".count-container");
    const totalCards = cards.length;

    const stickyHeight = window.innerHeight * 2;
    const getRadius = () => {
      return window.innerWidth < 900
        ? window.innerWidth * 7.5
        : window.innerWidth * 2.5;
    };

    const arcAngle = Math.PI * 0.4;
    const startAngle = Math.PI / 2 - arcAngle / 2;

    let currentCardIndex = 0;
    let scrollTriggerInstance = null;

    // Función para crear ScrollTrigger con configuración específica
    function createScrollTrigger() {
      if (scrollTriggerInstance) {
        scrollTriggerInstance.kill();
      }

      scrollTriggerInstance = ScrollTrigger.create({
        trigger: stickySection,
        start: "top top",
        end: `+=${stickyHeight}px`,
        pin: true,
        pinSpacing: !isChromeMotile, // Sin pinSpacing en Chrome móvil
        anticipatePin: !isChromeMotile ? 1 : 0,
        refreshPriority: isChromeMotile ? -1 : 0,
        onUpdate: (self) => {
          positionCards(self.progress);
          updateCounter(self.progress);
        },
        onRefresh: () => {
          // Asegurar posición inicial correcta
          positionCards(0);
          updateCounter(0);
        }
      });

      return scrollTriggerInstance;
    }

    // Crear ScrollTrigger inicial
    createScrollTrigger();

    function positionCards(progress) {
      const radius = getRadius();
      const totalTravel = 1 + totalCards / 7.5;
      const adjustProgress = (progress * totalTravel - 1) * 0.75;

      cards.forEach((card, i) => {
        const normalizedProgress = (totalCards - 1 - i) / totalCards;
        const cardProgress = normalizedProgress + adjustProgress;
        const angle = startAngle + arcAngle * cardProgress;

        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const rotation = (angle - Math.PI / 2) * (180 / Math.PI);

        gsap.set(card, {
          x: x,
          y: -y + radius,
          rotation: -rotation,
          transformOrigin: "center center",
        });
      });
    }

    function updateCounter(progress) {
      const radius = getRadius();
      const totalTravel = 1 + totalCards / 7.5;
      const adjustProgress = (progress * totalTravel - 1) * 0.75;

      let minDiff = Infinity;
      let bestIndex = 0;

      cards.forEach((card, i) => {
        const normalizedProgress = (totalCards - 1 - i) / totalCards;
        const cardProgress = normalizedProgress + adjustProgress;
        const angle = startAngle + arcAngle * cardProgress;
        const diff = Math.abs(angle - Math.PI / 2);

        if (diff < minDiff) {
          minDiff = diff;
          bestIndex = i;
        }
      });

      if (bestIndex !== currentCardIndex) {
        currentCardIndex = bestIndex;

        const slotHeight = window.innerWidth < 900 ? 100 : 150;
        const targetY = -currentCardIndex * slotHeight;

        gsap.to(countContainer, {
          y: targetY,
          duration: 0.3,
          ease: "power1.out",
          overwrite: true,
        });

        console.log("Cambiando a tarjeta:", currentCardIndex + 1);
      }
    }

    positionCards(0);
    gsap.set(countContainer, { y: 0 });
    updateCounter(0);

    // Sistema de prevención ultra-agresivo solo para Chrome móvil
    if (isChromeMotile) {
      let isInPinnedSection = false;
      let preventiveTimeout = null;

      // Interceptar scrollTo con lógica más inteligente
      const originalScrollTo = window.scrollTo;
      window.scrollTo = function(x, y) {
        if (typeof y === 'number') {
          const currentScroll = window.scrollY;
          const scrollDiff = Math.abs(y - currentScroll);
          
          // Solo bloquear si estamos EN la sección sticky Y es un salto grande
          const rect = stickySection.getBoundingClientRect();
          const isInStickySection = rect.top <= 0 && rect.bottom >= window.innerHeight;
          
          if (isInStickySection && scrollDiff > window.innerHeight * 1.5) {
            console.log("🚫 Salto bloqueado en sección sticky:", scrollDiff);
            return;
          }
        }
        return originalScrollTo.call(this, x, y);
      };

      // Monitorear entrada/salida con mejor precisión
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          // Actualizar estado basado en intersección
          const isVisible = entry.isIntersecting;
          const rect = entry.boundingClientRect;
          
          // Considerar "en sección" cuando está parcialmente visible
          isInPinnedSection = isVisible || (rect.top <= 0 && rect.bottom >= 0);
        });
      }, { 
        threshold: [0, 0.25, 0.5, 0.75, 1],
        rootMargin: '50px 0px 50px 0px' // Margen más generoso
      });
      
      observer.observe(stickySection);

      // Prevención adicional con MutationObserver
      const mutationObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && 
              mutation.attributeName === 'style' && 
              isInPinnedSection) {
            
            clearTimeout(preventiveTimeout);
            preventiveTimeout = setTimeout(() => {
              const rect = stickySection.getBoundingClientRect();
              if (rect.top > 100 || rect.top < -100) {
                console.log("Mutación anómala detectada - reconstruyendo...");
                createScrollTrigger();
              }
            }, 50);
          }
        });
      });
      
      mutationObserver.observe(stickySection, {
        attributes: true,
        attributeFilter: ['style']
      });
    }

    // Resize handler simplificado
    let resizeTimeout;
    let lastHeight = window.innerHeight;

    window.addEventListener("resize", () => {
      if (isChromeMotile) {
        // Para Chrome móvil, ser muy conservador
        const currentHeight = window.innerHeight;
        const heightDiff = Math.abs(currentHeight - lastHeight);
        
        if (heightDiff < 150) { // Threshold más alto
          return;
        }
        
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          createScrollTrigger(); // Recrear en lugar de refresh
          lastHeight = currentHeight;
        }, 200); // Delay reducido para más responsividad
      } else {
        // Lógica normal para otros navegadores
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          ScrollTrigger.refresh();
          positionCards(0);
        }, 100);
      }
    });

    // Solo para Chrome móvil - orientationchange
    if (isChromeMotile) {
      window.addEventListener("orientationchange", () => {
        setTimeout(() => {
          createScrollTrigger();
        }, 600);
      });
    }
  });
</script>